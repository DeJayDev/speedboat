From 39855e755dc0c3cfaf964030a64b582cb53872b3 Mon Sep 17 00:00:00 2001
From: DeJay <contact@dejaydev.com>
Date: Tue, 24 Dec 2019 19:15:56 -0600
Subject: [PATCH 23/24] Some other changes I can't remember, defo gonna remove
 this name

---
 rowboat/util/timing.py | 69 ++++++++++++++++--------------------------
 1 file changed, 26 insertions(+), 43 deletions(-)

diff --git a/rowboat/util/timing.py b/rowboat/util/timing.py
index e7c7894..6a7420c 100644
--- a/rowboat/util/timing.py
+++ b/rowboat/util/timing.py
@@ -9,56 +9,39 @@ from datetime import datetime
 
 class Eventual(object):
     """
-    A class which wraps a function which will be called at somepoint in the future.
+    A function that will be triggered eventually.
     """
 
     def __init__(self, func):
-        self.function = function
-
-        self._next_execution_time = None
-        self._waiter_greenlet = None
-        self._mutex = Semaphore()
-
-    def _execute(self):
-        """
-        Executes the Eventual function, guarded by a lock.
-        """
-        with self._mutex:
-            if self._waiter_greenlet:
-                self._waiter_greenlet.kill()
-                self._waiter_greenlet = None
-
-            self.function()
-            self._next_execution_time = None
-
-    def _waiter(self):
-        # Calculate the time we have to wait before next_execute_time
-        wait_duration = (self._next_execution_time - datetime.utcnow())
-
-        # Now start sleeping, we may not wake up if someone interrupts us with
-        #  a more recent next_execution_time
-        gevent.sleep(
-            (wait_duration.seconds) + (wait_duration.microseconds / 1000000.0)
-        )
-
-        # Finally execute the function, spawn this so when we kill our waiter
-        #  within _execute we don't die
-        gevent.spawn(self._execute)
+        self.func = func
+        self._next = None
+        self._t = None
+
+    def wait(self, nxt):
+        def f():
+            wait_time = (self._next - datetime.utcnow())
+            gevent.sleep(wait_time.seconds + (wait_time.microseconds / 1000000.0))
+            self._next = None
+            gevent.spawn(self.func)
+
+        if self._t:
+            self._t.kill()
+
+        self._next = nxt
+        self._t = gevent.spawn(f)
+
+    def trigger(self):
+        if self._t:
+            self._t.kill()
+        self._next = None
+        gevent.spawn(self.func)
 
     def set_next_schedule(self, date):
         if date < datetime.utcnow():
-            gevent.spawn(self._execute)
-            return
+            return gevent.spawn(self.trigger)
 
-        # Otherwise if we aren't waiting yet, OR if the time is newer than
-        #  our current next_execute_time we need to kill the waiter and spawn
-        #  a new one
-        if not self._next_execution_time or date < self._next_execution_time:
-            with self._mutex:
-                if self._waiter_greenlet:
-                    self._waiter_greenlet.kill()
-                self._next_execution_time = date
-                self._waiter_greenlet = gevent.spawn(self._waiter)
+        if not self._next or date < self._next:
+            self.wait(date)
 
 
 class Debounce(object):
-- 
2.24.1.windows.2

